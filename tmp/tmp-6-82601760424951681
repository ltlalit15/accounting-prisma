import React, { useState, useEffect, useRef, useCallback } from "react";
import {
  RiDashboardLine,
  RiTableLine,
  RiBarChartLine,
  RiSettingsLine,
  RiUserLine,
  RiNotificationLine,
  RiGridLine,
  RiListCheck,
  RiBilliardsLine,
  RiGamepadLine,
  RiRestaurantLine,
  RiStopLine,
  RiPlayLine,
  RiArrowDownSLine,
  RiCloseLine,
  RiPauseLine,
  RiPlayCircleLine,
  RiPrinterLine,
  RiDeleteBinLine,
} from "react-icons/ri";
import { FaPlaystation, FaPowerOff } from "react-icons/fa";
import {
  Modal,
  Button,
  Form,
  Dropdown,
  Badge,
  Toast,
  Spinner,
} from "react-bootstrap";
import { useNavigate } from "react-router-dom";
import MemberSelect from "./MemberSelect";
import { apiUrl } from "../../../utils/config";

const TablesManagement = () => {
  const navigate = useNavigate();
  const [showFoodModal, setShowFoodModal] = useState(false);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);
  // State declarations
  const [showTableModal, setShowTableModal] = useState(false);
  const [selectedSession, setSelectedSession] = useState(null);
  const [showCloseConfirm, setShowCloseConfirm] = useState(false);
  const [confirmToggleSession, setConfirmToggleSession] = useState(null);
  const [showToggleConfirm, setShowToggleConfirm] = useState(false);
  const [showStartSessionModal, setShowStartSessionModal] = useState(false);
  const [members, setMembers] = useState([]);
  const [selectedMember, setSelectedMember] = useState(null);
  const [customerOrders, setCustomerOrders] = useState([]);
  const [loadingCustomerOrders, setLoadingCustomerOrders] = useState(false);
  const [menuItems, setMenuItems] = useState([
    {
      id: 1,
      name: "Burger",
      price: 8.99,
      options: ["No Cheese", "Extra Cheese", "No Pickles"],
    },
    {
      id: 2,
      name: "Pizza",
      price: 12.99,
      options: ["Thin Crust", "Thick Crust", "Extra Sauce"],
    },
    {
      id: 3,
      name: "Salad",
      price: 7.99,
      options: ["No Dressing", "Extra Dressing", "Add Chicken"],
    },
  ]);
  const [selectedItems, setSelectedItems] = useState([]);
  const [itemOptions, setItemOptions] = useState({});
  const [currentTime, setCurrentTime] = useState("");
  const [tableTypeFilter, setTableTypeFilter] = useState("all");
  const [viewMode, setViewMode] = useState("grid");
  const [timeLimit, setTimeLimit] = useState(60); // Default to 60 minutes
  const [amount, setAmount] = useState(10); // Default amount for 60 minutes at $10/hr
  const hourlyRate = 10;
  const [sessions, setSessions] = useState([]);
  const [availableTables, setAvailableTables] = useState([]);
  const [selectedTableForStart, setSelectedTableForStart] = useState(null);
  const [currentUser, setCurrentUser] = useState(null);
  const [showBillModal, setShowBillModal] = useState(false);
  const [billData, setBillData] = useState(null);
  const [showDeleteConfirm, setShowDeleteConfirm] = useState(false);
  const [sessionToDelete, setSessionToDelete] = useState(null);
  // New states for transfer functionality
  const [showTransferModal, setShowTransferModal] = useState(false);
  const [sessionToTransfer, setSessionToTransfer] = useState(null);
  const [transferTableId, setTransferTableId] = useState("");
  const [electricTables, setElectricTables] = useState([]);
  // New states for session timers
  const [sessionTimers, setSessionTimers] = useState({});
  // New state for business settings including tax
  const [businessSettings, setBusinessSettings] = useState({
    tax: 10, // Default tax rate
  });
  // New states for device/plug control
  const [devices, setDevices] = useState([]);
  const [updatingDevices, setUpdatingDevices] = useState({});
  const [showToast, setShowToast] = useState(false);
  const [toastMessage, setToastMessage] = useState("");
  // Printer settings state
  const [printerConfig, setPrinterConfig] = useState({
    host: "192.168.1.100",
    port: 9100,
    type: "epson",
  });
  // Printer settings modal state
  const [showPrinterSettings, setShowPrinterSettings] = useState(false);
  // New state for closing session loading
  const [isClosingSession, setIsClosingSession] = useState(false);
  // New state for deleting session loading
  const [isDeletingSession, setIsDeletingSession] = useState(false);
  // New state to prevent API loops
  const [isFetchingSessions, setIsFetchingSessions] = useState(false);
  // New state for starting session loading
  const [isStartingSession, setIsStartingSession] = useState(false);

  // Define allowed table types
  const allowedTableTypes = ["pool", "snooker", "playstation"];

  const sessionsRef = useRef(sessions);
  sessionsRef.current = sessions;

  // Load printer settings from localStorage on component mount
  useEffect(() => {
    const savedConfig = localStorage.getItem("printerConfig");
    if (savedConfig) {
      try {
        setPrinterConfig(JSON.parse(savedConfig));
      } catch (err) {
        console.error("Error loading printer config:", err);
      }
    }
  }, []);

  // Fetch business settings including tax rate
  useEffect(() => {
    const fetchBusinessSettings = async () => {
      try {
        const response = await fetch(`${apiUrl}/business_settings`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.success) {
          setBusinessSettings(data.data);
        } else {
          throw new Error(data.message || "Failed to fetch business settings");
        }
      } catch (err) {
        console.error("Error fetching business settings:", err);
        // Keep default tax rate if API fails
      }
    };
    fetchBusinessSettings();
  }, []);

  // Fetch devices/plugs
  useEffect(() => {
    const fetchDevices = async () => {
      try {
        const response = await fetch(`${apiUrl}/plugs`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.success) {
          setDevices(data.data.plugs || []);
          console.log("Devices loaded:", data.data.plugs);
        }
      } catch (err) {
        console.error("Error fetching devices:", err);
      }
    };
    fetchDevices();
  }, []);

  // Fetch electric tables for transfer functionality - only allowed types
  useEffect(() => {
    const fetchElectricTables = async () => {
      try {
        const response = await fetch(
          `${apiUrl}/tables?electric=true&status=available`,
          {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          }
        );
        if (response.ok) {
          const data = await response.json();
          if (data.success) {
            // Filter tables to only include allowed types
            const filteredTables = (data.data.tables || []).filter((table) =>
              allowedTableTypes.includes(table.table_type)
            );
            setElectricTables(filteredTables);
          }
        }
      } catch (err) {
        console.error("Error fetching electric tables:", err);
      }
    };
    fetchElectricTables();
  }, []);

  // Format time for display (MM:SS)
  const formatTime = useCallback((seconds) => {
    if (seconds === undefined || seconds === null || isNaN(seconds))
      return "N/A";
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    return `${mins}:${secs < 10 ? "0" : ""}${secs}`;
  }, []);

  // Parse time limit from string format like "2 * 60" to get minutes
  const parseTimeLimit = useCallback((timeLimitStr) => {
    if (!timeLimitStr) return null;
    // If it's already a number, return it
    if (typeof timeLimitStr === "number") {
      return timeLimitStr;
    }
    // Try to parse string format like "2 * 60"
    const parts = timeLimitStr.toString().split("*");
    if (parts.length >= 2) {
      const minutes = parseFloat(parts[0].trim());
      if (!isNaN(minutes)) {
        return minutes;
      }
    }
    // Try to parse as plain number
    const minutes = parseFloat(timeLimitStr);
    if (!isNaN(minutes)) {
      return minutes;
    }
    return null;
  }, []);

  // Calculate remaining time for a session
  const calculateRemainingTime = useCallback(
    (session) => {
      if (!session.time_limit || session.status !== "active") return null;
      // Parse time limit to get minutes
      const timeLimitMinutes = parseTimeLimit(session.time_limit);
      if (timeLimitMinutes === null || timeLimitMinutes === 0) return null; // Return null for unlimited time
      const createdTime = new Date(session.created_at).getTime();
      const elapsedSeconds = (Date.now() - createdTime) / 1000;
      const totalSeconds = timeLimitMinutes * 60; // Convert minutes to seconds
      return Math.max(0, totalSeconds - elapsedSeconds);
    },
    [parseTimeLimit]
  );

  // Calculate session cost based on time limit or actual usage time
  const calculateSessionCost = useCallback(
    (session, endTime = new Date()) => {
      if (!session) return 0;

      const hourlyRate = parseFloat(session.hourly_rate || hourlyRate);

      // Check if session has a time limit (not unlimited)
      const timeLimitMinutes = parseTimeLimit(session.time_limit);

      if (timeLimitMinutes > 0) {
        // For sessions with a time limit, calculate cost based on the time limit
        const durationHours = timeLimitMinutes / 60;
        return durationHours * hourlyRate;
      } else {
        // For unlimited sessions, calculate cost based on actual usage time
        const startTime = new Date(session.start_time);
        const durationMinutes = Math.floor((endTime - startTime) / 60000);
        const durationHours = durationMinutes / 60;
        return durationHours * hourlyRate;
      }
    },
    [hourlyRate, parseTimeLimit]
  );

  // Update session timers
  useEffect(() => {
    const interval = setInterval(() => {
      setSessionTimers((prev) => {
        const newTimers = { ...prev };
        const currentSessions = sessionsRef.current;

        currentSessions.forEach((session) => {
          if (session.status === "active") {
            const remaining = calculateRemainingTime(session);
            newTimers[session.id] = remaining;

            // Auto-end session when time is up (only if time limit is set and not 0)
            if (
              remaining !== null &&
              parseInt(remaining) === 0 &&
              parseTimeLimit(session.time_limit) > 0
            ) {
              endSession(session.id);
            }
          }
        });
        return newTimers;
      });

      // Update session costs in real-time
      setSessions((prevSessions) =>
        prevSessions.map((session) => {
          if (session.status === "active") {
            const cost = calculateSessionCost(session);
            return { ...session, session_cost: cost.toFixed(2) };
          }
          return session;
        })
      );
    }, 1000);
    return () => clearInterval(interval);
  }, [calculateRemainingTime, calculateSessionCost, parseTimeLimit]);

  // Load current user data
  useEffect(() => {
    const userData = JSON.parse(localStorage.getItem("user"));
    setCurrentUser(userData);
  }, []);

  // Fetch members from API
  useEffect(() => {
    const fetchMembers = async () => {
      try {
        const response = await fetch(`${apiUrl}/users?role=user`, {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        });
        if (!response.ok) {
          throw new Error(`HTTP error! status: ${response.status}`);
        }
        const data = await response.json();
        if (data.success) {
          const formattedMembers = data.data.users.map((user) => ({
            id: user.id,
            name: user.name,
            discount: parseFloat(user.discount_percentage) || 0,
            phone: user.phone,
            email: user.email,
            status: user.status,
            role: user.role,
          }));
          setMembers(formattedMembers);
        } else {
          throw new Error(data.message || "Failed to fetch members");
        }
      } catch (err) {
        console.error("Error fetching members:", err);
        setMembers([
          {
            id: 1,
            name: "John Doe",
            discount: 10,
            phone: "123-456-7890",
            role: "user",
          },
          {
            id: 2,
            name: "Jane Smith",
            discount: 5,
            phone: "123-456-7891",
            role: "user",
          },
          {
            id: 3,
            name: "Mike Johnson",
            discount: 15,
            phone: "123-456-7892",
            role: "user",
          },
          {
            id: 4,
            name: "Sarah Williams",
            discount: 0,
            phone: "123-456-7893",
            role: "user",
          },
          {
            id: 5,
            name: "Admin User",
            discount: 0,
            phone: "123-456-7894",
            role: "admin",
          },
          {
            id: 6,
            name: "Staff User",
            discount: 0,
            phone: "123-456-7895",
            role: "staff",
          },
        ]);
      }
    };
    fetchMembers();
  }, []);

  // Fetch sessions from API
  const fetchSessions = useCallback(async () => {
    // Prevent multiple simultaneous API calls
    if (isFetchingSessions) return;

    setIsFetchingSessions(true);
    try {
      const response = await fetch(`${apiUrl}/sessions`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!response.ok) {
        throw new Error(`HTTP error! status: ${response.status}`);
      }
      const data = await response.json();
      if (data.success) {
        // Filter sessions to only include allowed table types
        const filteredSessions = (data.data.sessions || []).filter((session) =>
          allowedTableTypes.includes(session.table_type)
        );
        setSessions(filteredSessions);
      } else {
        throw new Error(data.message || "Failed to fetch sessions");
      }
    } catch (err) {
      console.error("Error fetching sessions:", err);
      setError(err.message);
      // Filter default sessions to only include allowed table types
      const defaultSessions = [
        {
          id: 5,
          session_id: "SES-1755757269519-190",
          table_id: 28,
          user_id: 11,
          customer_name: "new user",
          customer_phone: "9878458596",
          created_at: "2025-08-21 06:21:09",
          updated_at: null,
          duration_minutes: 0,
          hourly_rate: "12.00",
          session_cost: "0.00",
          status: "active",
          amount: null,
          time_limit: 30, // Stored in minutes
          table_number: "P20",
          table_name: "Pool Table 3",
          table_type: "pool",
          user_name: "govind singh",
        },
      ].filter((session) => allowedTableTypes.includes(session.table_type));
      setSessions(defaultSessions);
    } finally {
      setLoading(false);
      setIsFetchingSessions(false);
    }
  }, [allowedTableTypes, isFetchingSessions]);

  // Initial fetch of sessions - only run once on component mount
  useEffect(() => {
    fetchSessions();
  }, []); // Empty dependency array ensures this runs only once

  // Fetch available tables for starting new session - only allowed types
  const fetchAvailableTables = async () => {
    try {
      const response = await fetch(`${apiUrl}/tables?status=available`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          // Filter tables to only include allowed types
          const filteredTables = (data.data.tables || []).filter((table) =>
            allowedTableTypes.includes(table.table_type)
          );
          setAvailableTables(filteredTables);
        }
      }
    } catch (err) {
      console.error("Error fetching available tables:", err);
    }
  };

  // Clear orders for a table
  const clearTableOrders = async (tableId) => {
    try {
      const response = await fetch(`${apiUrl}/tables/${tableId}/clear-orders`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!response.ok) {
        console.error("Failed to clear table orders");
      }
    } catch (err) {
      console.error("Error clearing table orders:", err);
    }
  };

  // Toggle device power (plug on/off)
  const toggleDevicePower = async (deviceId, action) => {
    const device = devices.find((d) => d.id === deviceId);
    if (!device) {
      console.error(`Device with ID ${deviceId} not found`);
      return;
    }
    if (device.status === "offline") {
      setToastMessage(`Cannot control ${device.name} - device is offline`);
      setShowToast(true);
      setTimeout(() => setShowToast(false), 3000);
      return;
    }
    // Show loading state
    setUpdatingDevices((prev) => ({ ...prev, [deviceId]: true }));
    try {
      console.log(
        `Toggling device ${device.name} (ID: ${deviceId}) to ${action}`
      );
      const response = await fetch(`${apiUrl}/plugs/${deviceId}/power`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          action: action,
        }),
      });
      if (!response.ok) {
        const errorData = await response.json();
        console.error("Error response from plug control API:", errorData);
        throw new Error(
          `HTTP error! status: ${response.status}, message: ${
            errorData.message || "Unknown error"
          }`
        );
      }
      const data = await response.json();
      console.log("Plug control response:", data);
      if (data.success) {
        // Update device state on success
        setDevices(
          devices.map((device) => {
            if (device.id === deviceId) {
              const message = `${
                device.name
              } has been turned ${action.toUpperCase()}`;
              setToastMessage(message);
              setShowToast(true);
              setTimeout(() => setShowToast(false), 3000);
              return {
                ...device,
                powerState: action,
                lastUpdated: "Just now",
              };
            }
            return device;
          })
        );
      } else {
        throw new Error(data.message || "API response indicates failure");
      }
    } catch (err) {
      console.error("Error toggling device power:", err);
      setToastMessage(
        `Failed to toggle power for ${device.name}: ${err.message}`
      );
      setShowToast(true);
      setTimeout(() => setShowToast(false), 3000);
    } finally {
      // Remove loading state
      setUpdatingDevices((prev) => ({ ...prev, [deviceId]: false }));
    }
  };

  // Transfer session to another table
  const transferSession = async (sessionId, newTableId) => {
    try {
      const session = sessions.find((s) => s.id === sessionId);
      if (!session) {
        throw new Error("Session not found");
      }

      console.log("electricTables", electricTables);
      console.log("new table id", newTableId);

      const newTable = electricTables.find(
        (t) => t.id.toString() == newTableId
      );
      if (!newTable) {
        throw new Error("Selected table not found");
      }
      // First, end the current session
      const endResponse = await fetch(`${apiUrl}/sessions/${sessionId}/end`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (!endResponse.ok) {
        throw new Error("Failed to end current session");
      }
      // Turn off the device for the current table
      const currentDevice = devices.find(
        (device) => device.table_id === session.table_id
      );
      if (currentDevice) {
        await toggleDevicePower(currentDevice.id, "off");
      }
      // Then, start a new session on the selected table
      const userId = currentUser?.id;
      const customerName = session.customer_name || "Guest";
      const customerPhone = session.customer_phone || "";
      const formattedTimeLimit = session.time_limit
        ? `${parseTimeLimit(session.time_limit)} * 60`
        : "0 * 60";
      const startResponse = await fetch(`${apiUrl}/sessions/start`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          table_id: parseInt(newTableId),
          customer_name: customerName,
          customer_phone: customerPhone,
          user_id: userId.toString(),
          amount: session.amount || 0,
          time_limit: formattedTimeLimit,
        }),
      });
      if (!startResponse.ok) {
        throw new Error("Failed to start new session");
      }
      const startData = await startResponse.json();
      if (startData.success) {
        // Add the new session to state
        setSessions((prevSessions) => [
          ...prevSessions,
          startData.data.session,
        ]);
        // Turn on the device for the new table
        const newDevice = devices.find(
          (device) => device.table_id === parseInt(newTableId)
        );
        if (newDevice) {
          await toggleDevicePower(newDevice.id, "on");
        }
        // Remove the old session from state
        setSessions((prevSessions) =>
          prevSessions.filter((s) => s.id !== sessionId)
        );
        return true;
      } else {
        throw new Error(startData.message || "Failed to start new session");
      }
    } catch (err) {
      console.error("Error transferring session:", err);
      alert(`Error transferring session: ${err.message}`);
      return false;
    }
  };

  // Handler for session click
  const handleSessionClick = (session) => {
    setSelectedSession(session);
    setShowTableModal(true);
    setSelectedItems([]);
    setItemOptions({});
  };

  // Confirm close and print
  const fetchBillForEndedSession = async (session) => {
    try {
      // Calculate table cost based on time limit or actual usage time
      const endTime = new Date(session.end_time);
      const startTime = new Date(session.start_time);
      const hourlyRate = parseFloat(session.hourly_rate || hourlyRate);

      // Check if session has a time limit (not unlimited)
      const timeLimitMinutes = parseTimeLimit(session.time_limit);
      let tableCost;

      if (timeLimitMinutes > 0) {
        // For sessions with a time limit, calculate cost based on the time limit
        const durationHours = timeLimitMinutes / 60;
        tableCost = durationHours * hourlyRate;
      } else {
        // For unlimited sessions, calculate cost based on actual usage time
        const durationMinutes = Math.floor((endTime - startTime) / 60000);
        const durationHours = durationMinutes / 60;
        tableCost = durationHours * hourlyRate;
      }

      // Fetch orders for this session
      const ordersResponse = await fetch(
        `${apiUrl}/orders/session/${session.id}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        }
      );
      let orders = [];
      let ordersTotal = 0;
      if (ordersResponse.ok) {
        const ordersData = await ordersResponse.json();
        if (ordersData.success) {
          orders = ordersData.data.orders;
          ordersTotal = orders.reduce(
            (sum, order) => sum + parseFloat(order.total_amount),
            0
          );
        }
      }
      // Calculate bill totals using tax from business settings
      const taxRate = parseFloat(businessSettings.tax) / 100;
      const subtotal = tableCost + ordersTotal;
      const tax = subtotal * taxRate;
      const total = subtotal + tax;

      // Calculate duration for display
      const durationMinutes =
        timeLimitMinutes > 0
          ? timeLimitMinutes
          : Math.floor((endTime - startTime) / 60000);

      const bill = {
        sessionId: session.session_id,
        tableName: session.table_name,
        tableType: session.table_type,
        customerName: session.customer_name || "Guest",
        startTime: startTime.toLocaleString(),
        endTime: endTime.toLocaleString(),
        duration: `${Math.floor(durationMinutes / 60)}h ${
          durationMinutes % 60
        }m`,
        hourlyRate: hourlyRate,
        tableCost: tableCost,
        orders: orders,
        ordersTotal: ordersTotal,
        subtotal: subtotal,
        tax: tax,
        taxRate: businessSettings.tax,
        total: total,
      };
      setBillData(bill);
      setShowBillModal(true);
    } catch (err) {
      console.error("Error fetching bill data:", err);
      alert("Error fetching bill data. Please try again.");
    }
  };

  const confirmCloseAndPrint = async () => {
    setIsClosingSession(true); // Start loading state
    try {
      const response = await fetch(
        `${apiUrl}/sessions/${selectedSession.id}/end`,
        {
          method: "PATCH",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        }
      );
      if (response.ok) {
        const endTime = new Date();
        const startTime = new Date(selectedSession.start_time);
        const hourlyRate = parseFloat(
          selectedSession.hourly_rate || hourlyRate
        );

        // Check if session has a time limit (not unlimited)
        const timeLimitMinutes = parseTimeLimit(selectedSession.time_limit);
        let tableCost;

        if (timeLimitMinutes > 0) {
          // For sessions with a time limit, calculate cost based on the time limit
          const durationHours = timeLimitMinutes / 60;
          tableCost = durationHours * hourlyRate;
        } else {
          // For unlimited sessions, calculate cost based on actual usage time
          const durationMinutes = Math.floor((endTime - startTime) / 60000);
          const durationHours = durationMinutes / 60;
          tableCost = durationHours * hourlyRate;
        }

        // Fetch orders for this session
        const ordersResponse = await fetch(
          `${apiUrl}/orders/session/${selectedSession.id}`,
          {
            method: "GET",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          }
        );
        let orders = [];
        let ordersTotal = 0;
        if (ordersResponse.ok) {
          const ordersData = await ordersResponse.json();
          if (ordersData.success) {
            orders = ordersData.data.orders;
            ordersTotal = orders.reduce(
              (sum, order) => sum + parseFloat(order.total_amount),
              0
            );
          }
        }
        // Calculate bill totals using tax from business settings
        const taxRate = parseFloat(businessSettings.tax) / 100;
        const subtotal = tableCost + ordersTotal;
        const tax = subtotal * taxRate;
        const total = subtotal + tax;

        // Calculate duration for display
        const durationMinutes =
          timeLimitMinutes > 0
            ? timeLimitMinutes
            : Math.floor((endTime - startTime) / 60000);

        const bill = {
          sessionId: selectedSession.session_id,
          tableName: selectedSession.table_name,
          tableType: selectedSession.table_type,
          customerName: selectedSession.customer_name || "Guest",
          startTime: startTime.toLocaleString(),
          endTime: endTime.toLocaleString(),
          duration: `${Math.floor(durationMinutes / 60)}h ${
            durationMinutes % 60
          }m`,
          hourlyRate: hourlyRate,
          tableCost: tableCost,
          orders: orders,
          ordersTotal: ordersTotal,
          subtotal: subtotal,
          tax: tax,
          taxRate: businessSettings.tax,
          total: total,
        };
        setBillData(bill);
        setShowBillModal(true);
        // Find and turn off the plug associated with this table
        console.log(
          "Looking for plug with table_id:",
          selectedSession.table_id
        );
        console.log("Available plugs:", devices);
        const tableDevice = devices.find((device) => {
          console.log(
            `Checking device ${device.id}: table_id=${device.table_id}, looking for ${selectedSession.table_id}`
          );
          return device.table_id === selectedSession.table_id;
        });
        if (tableDevice) {
          console.log(
            `Found device ${tableDevice.name} for table ${selectedSession.table_id}, turning off`
          );
          await toggleDevicePower(tableDevice.id, "off");
        } else {
          console.log(`No device found for table ${selectedSession.table_id}`);
        }

        // Clear all orders for this table
        await clearTableOrders(selectedSession.table_id);

        // Remove the session from state
        setSessions((prevSessions) =>
          prevSessions.filter((session) => session.id !== selectedSession.id)
        );

        // Refresh sessions data from the server
        await fetchSessions();
      } else {
        throw new Error("Failed to close session");
      }
    } catch (err) {
      console.error("Error closing session:", err);
      alert("Error closing session. Please try again.");
    } finally {
      setIsClosingSession(false); // End loading state
      setShowCloseConfirm(false);
      setShowTableModal(false);
    }
  };

  // Start new session
  const startNewSession = async () => {
    if (!selectedTableForStart) {
      alert("Please select a table");
      return;
    }
    setIsStartingSession(true); // Start loading state
    try {
      const userId = currentUser?.id;
      const customerName = selectedMember ? selectedMember.name : "Guest";
      const customerPhone = selectedMember ? selectedMember.phone : "";
      // Format time limit as string like "2 * 60" if needed by backend
      // If timeLimit is 0, pass "0 * 60" to indicate unlimited time
      const formattedTimeLimit = timeLimit ? `${timeLimit} * 60` : "0 * 60";
      const response = await fetch(`${apiUrl}/sessions/start`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          table_id: parseInt(selectedTableForStart.id),
          customer_name: customerName,
          customer_phone: customerPhone,
          user_id: userId.toString(),
          amount: amount || 0,
          time_limit: formattedTimeLimit,
        }),
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          // Add the new session to state
          setSessions((prevSessions) => [...prevSessions, data.data.session]);
          // Find and turn on the plug associated with this table
          console.log(
            "Looking for plug with table_id:",
            selectedTableForStart.id
          );
          console.log("Available plugs:", devices);
          const tableDevice = devices.find((device) => {
            console.log(
              `Checking device ${device.id}: table_id=${device.table_id}, looking for ${selectedTableForStart.id}`
            );
            return device.table_id === selectedTableForStart.id;
          });
          if (tableDevice) {
            console.log(
              `Found device ${tableDevice.name} for table ${selectedTableForStart.id}, turning on`
            );
            await toggleDevicePower(tableDevice.id, "on");
          } else {
            console.log(
              `No device found for table ${selectedTableForStart.id}`
            );
          }
          alert("Session started successfully!");
          setShowStartSessionModal(false);

          // Refresh sessions data from the server
          await fetchSessions();
        }
      } else {
        const errorData = await response.json();
        throw new Error(errorData.message || "Failed to start session");
      }
    } catch (err) {
      console.error("Error starting session:", err);
      alert(`Error starting session: ${err.message}`);
    } finally {
      setIsStartingSession(false); // End loading state
    }
  };

  // Pause session
  const pauseSession = async (sessionId) => {
    try {
      const response = await fetch(`${apiUrl}/sessions/${sessionId}/pause`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (response.ok) {
        setSessions((prevSessions) =>
          prevSessions.map((session) =>
            session.id === sessionId
              ? { ...session, status: "paused" }
              : session
          )
        );

        // Refresh sessions data from the server
        await fetchSessions();
      } else {
        throw new Error("Failed to pause session");
      }
    } catch (err) {
      console.error("Error pausing session:", err);
      alert("Error pausing session. Please try again.");
    }
  };

  // Resume session
  const resumeSession = async (sessionId) => {
    try {
      const response = await fetch(`${apiUrl}/sessions/${sessionId}/resume`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (response.ok) {
        setSessions((prevSessions) =>
          prevSessions.map((session) =>
            session.id === sessionId
              ? { ...session, status: "active" }
              : session
          )
        );

        // Refresh sessions data from the server
        await fetchSessions();
      } else {
        throw new Error("Failed to resume session");
      }
    } catch (err) {
      console.error("Error resuming session:", err);
      alert("Error resuming session. Please try again.");
    }
  };

  // End session
  const endSession = async (sessionId) => {
    try {
      const session = sessions.find((s) => s.id === sessionId);
      if (!session) return;
      const response = await fetch(`${apiUrl}/sessions/${sessionId}/end`, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (response.ok) {
        // Find and turn off the plug associated with this table
        console.log("Looking for plug with table_id:", session.table_id);
        console.log("Available plugs:", devices);
        const tableDevice = devices.find((device) => {
          console.log(
            `Checking device ${device.id}: table_id=${device.table_id}, looking for ${session.table_id}`
          );
          return device.table_id === session.table_id;
        });
        if (tableDevice) {
          console.log(
            `Found device ${tableDevice.name} for table ${session.table_id}, turning off`
          );
          await toggleDevicePower(tableDevice.id, "off");
        } else {
          console.log(`No device found for table ${session.table_id}`);
        }

        // Clear all orders for this table
        await clearTableOrders(session.table_id);

        setSessions((prevSessions) =>
          prevSessions.filter((session) => session.id !== sessionId)
        );
        // Remove timer for this session
        setSessionTimers((prev) => {
          const newTimers = { ...prev };
          delete newTimers[sessionId];
          return newTimers;
        });
        alert("Session ended automatically as time limit was reached.");

        // Refresh sessions data from the server
        await fetchSessions();
      } else {
        throw new Error("Failed to end session");
      }
    } catch (err) {
      console.error("Error ending session:", err);
      alert("Error ending session. Please try again.");
    }
  };

  // Delete session
  const deleteSession = async () => {
    if (!sessionToDelete) return;
    setIsDeletingSession(true); // Start loading state
    try {
      const response = await fetch(`${apiUrl}/sessions/${sessionToDelete.id}`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (response.ok) {
        setSessions((prevSessions) =>
          prevSessions.filter((session) => session.id !== sessionToDelete.id)
        );
        // Remove timer for this session
        setSessionTimers((prev) => {
          const newTimers = { ...prev };
          delete newTimers[sessionToDelete.id];
          return newTimers;
        });
        alert("Session deleted successfully!");

        // Refresh sessions data from the server
        await fetchSessions();
      } else {
        throw new Error("Failed to delete session");
      }
    } catch (err) {
      console.error("Error deleting session:", err);
      alert("Error deleting session. Please try again.");
    } finally {
      setIsDeletingSession(false); // End loading state
      setShowDeleteConfirm(false);
      setSessionToDelete(null);
    }
  };

  // Add item to order
  const addItemToOrder = (item) => {
    setSelectedItems([...selectedItems, item]);
    setItemOptions({ ...itemOptions, [item.id]: [] });
  };

  // Remove item from order
  const removeItemFromOrder = (itemId) => {
    setSelectedItems(selectedItems.filter((item) => item.id !== itemId));
    const newOptions = { ...itemOptions };
    delete newOptions[itemId];
    setItemOptions(newOptions);
  };

  // Update item options
  const handleOptionChange = (itemId, option, isChecked) => {
    setItemOptions((prev) => {
      const currentOptions = prev[itemId] || [];
      const newOptions = isChecked
        ? [...currentOptions, option]
        : currentOptions.filter((opt) => opt !== option);
      return { ...prev, [itemId]: newOptions };
    });
  };

  // Print bill using Wi-Fi printer API
  const printBill = async () => {
    if (!billData) {
      alert("No bill data available");
      return;
    }
    try {
      const response = await fetch(`${apiUrl}/print/wifi`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          billData: billData,
          printerConfig: printerConfig,
        }),
      });
      const data = await response.json();
      if (data.success) {
        alert("Bill printed successfully!");
      } else {
        throw new Error(data.message || "Failed to print bill");
      }
    } catch (err) {
      console.error("Error printing bill:", err);
      alert(`Error printing bill: ${err.message}`);
    }
  };

  // Test print function
  const testPrint = async () => {
    try {
      const response = await fetch(`${apiUrl}/print/test`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
        body: JSON.stringify({
          printerConfig: printerConfig,
        }),
      });
      const data = await response.json();
      if (data.success) {
        alert("Test print successful!");
      } else {
        throw new Error(data.message || "Test print failed");
      }
    } catch (err) {
      alert(`Test print failed: ${err.message}`);
    }
  };

  // Save printer settings
  const savePrinterSettings = () => {
    localStorage.setItem("printerConfig", JSON.stringify(printerConfig));
    setShowPrinterSettings(false);
    alert("Printer settings saved successfully!");
  };

  // Update current time
  useEffect(() => {
    const updateClock = () => {
      const now = new Date();
      const timeString = now.toLocaleTimeString("en-US", { hour12: false });
      setCurrentTime(timeString);
    };
    updateClock();
    const interval = setInterval(updateClock, 1000);
    return () => clearInterval(interval);
  }, []);

  // Filter sessions by table type
  const filteredSessions = sessions.filter(
    (session) =>
      tableTypeFilter === "all" || session.table_type === tableTypeFilter
  );

  // Get table icon based on type
  const getTableIcon = (type) => {
    switch (type) {
      case "snooker":
        return <RiBilliardsLine className="text-success fs-6" />;
      case "pool":
        return <RiBilliardsLine className="text-primary fs-6" />;
      case "playstation":
        return <FaPlaystation className="text-purple fs-6" />;
      case "restaurant":
        return <RiRestaurantLine className="text-warning fs-6" />;
      default:
        return <RiTableLine className="text-secondary fs-6" />;
    }
  };

  // Get table icon background based on type
  const getTableIconBg = (type) => {
    switch (type) {
      case "snooker":
        return "bg-success bg-opacity-10";
      case "pool":
        return "bg-primary bg-opacity-10";
      case "playstation":
        return "bg-purple bg-opacity-10";
      case "restaurant":
        return "bg-warning bg-opacity-10";
      default:
        return "bg-secondary bg-opacity-10";
    }
  };

  // Get session status badge class
  const getStatusBadgeClass = (status) => {
    switch (status) {
      case "active":
        return "bg-success bg-opacity-10 text-success";
      case "paused":
        return "bg-warning bg-opacity-10 text-warning";
      case "ended":
        return "bg-secondary bg-opacity-10 text-secondary";
      default:
        return "bg-info bg-opacity-10 text-info";
    }
  };

  // Render member select dropdown
  const renderMemberSelect = () => (
    <MemberSelect
      members={members}
      selectedMember={selectedMember}
      setSelectedMember={setSelectedMember}
      setMembers={setMembers}
    />
  );

  // Render menu items for restaurant
  const renderMenuItems = () => (
    <div className="mb-3">
      <h5>Menu Items</h5>
      <div className="d-flex flex-wrap gap-2 mb-3">
        {menuItems.map((item) => (
          <Button
            key={item.id}
            variant="outline-primary"
            size="sm"
            onClick={() => addItemToOrder(item)}
          >
            {item.name} - ${item.price.toFixed(2)}
          </Button>
        ))}
      </div>
      {selectedItems.length > 0 && (
        <div className="border rounded p-3">
          <h6>Selected Items</h6>
          {selectedItems.map((item) => (
            <div key={item.id} className="mb-2 border-bottom pb-2">
              <div className="d-flex justify-content-between align-items-center">
                <div className="fw-medium">
                  {item.name} - ${item.price.toFixed(2)}
                </div>
                <Button
                  variant="link"
                  size="sm"
                  className="text-danger p-0"
                  onClick={() => removeItemFromOrder(item.id)}
                >
                  <RiCloseLine />
                </Button>
              </div>
              {item.options.length > 0 && (
                <div className="mt-1">
                  <small className="text-muted d-block mb-1">Options:</small>
                  <div className="d-flex flex-wrap gap-2">
                    {item.options.map((option) => (
                      <Form.Check
                        key={option}
                        type="checkbox"
                        label={option}
                        checked={(itemOptions[item.id] || []).includes(option)}
                        onChange={(e) =>
                          handleOptionChange(item.id, option, e.target.checked)
                        }
                      />
                    ))}
                  </div>
                </div>
              )}
            </div>
          ))}
        </div>
      )}
    </div>
  );

  // Toast notification component
  const ToastNotification = () => (
    <div
      className={`position-fixed bottom-0 end-0 p-3 ${
        showToast ? "d-block" : "d-none"
      }`}
      style={{ zIndex: 1050 }}
    >
      <Toast
        onClose={() => setShowToast(false)}
        show={showToast}
        delay={3000}
        autohide
      >
        <Toast.Header>
          <strong className="me-auto">Device Control</strong>
        </Toast.Header>
        <Toast.Body>{toastMessage}</Toast.Body>
      </Toast>
    </div>
  );

  if (loading) {
    return <div className="p-3 text-center">Loading sessions...</div>;
  }
  if (error) {
    return <div className="p-3 text-center text-danger">Error: {error}</div>;
  }

  const fetchCustomerOrders = async (sessionId) => {
    setLoadingCustomerOrders(true);
    try {
      const response = await fetch(`${apiUrl}/orders/session/${sessionId}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${localStorage.getItem("token")}`,
        },
      });
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          setCustomerOrders(data.data.orders || []);
        } else {
          console.error("Failed to fetch customer orders:", data.message);
          setCustomerOrders([]);
        }
      } else {
        console.error("Failed to fetch customer orders");
        setCustomerOrders([]);
      }
    } catch (err) {
      console.error("Error fetching customer orders:", err);
      setCustomerOrders([]);
    } finally {
      setLoadingCustomerOrders(false);
    }
  };

  const calculateTotalCost = () => {
    if (!selectedSession) return 0;

    // Calculate table cost
    const tableCost = parseFloat(selectedSession.session_cost || 0);

    // Calculate customer orders total
    const ordersTotal = customerOrders.reduce(
      (sum, order) => sum + parseFloat(order.total_amount || 0),
      0
    );

    // Return sum of both
    return tableCost + ordersTotal;
  };

  const handleCloseSession = async () => {
    if (!selectedSession) return;

    // Show loading state in modal (optional)
    setCustomerOrders([]); // Clear stale data
    setLoadingCustomerOrders(true);

    try {
      const response = await fetch(
        `${apiUrl}/orders/session/${selectedSession.id}`,
        {
          method: "GET",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${localStorage.getItem("token")}`,
          },
        }
      );

      let orders = [];
      if (response.ok) {
        const data = await response.json();
        if (data.success) {
          orders = data.data.orders || [];
        }
      }

      setCustomerOrders(orders);
    } catch (err) {
      console.error("Error fetching orders for modal:", err);
      setCustomerOrders([]);
    } finally {
      setLoadingCustomerOrders(false);
      setShowCloseConfirm(true); // ✅ Open modal ONLY after data is ready
    }
  };

  // ✅ Helper to reset orders when modal closes
  const handleCloseConfirmModal = () => {
    setCustomerOrders([]);
    setShowCloseConfirm(false);
  };

  return (
    <div className="p-3">
      {/* Main Content */}
      <div className="d-flex flex-column flex-grow-1 overflow-hidden">
        {/* Header */}
        <header className="">
          <div className="d-flex align-items-center justify-content-between flex-wrap gap-3">
            <div>
              <h1 className="fs-3 fw-bold text-dark">Sessions Management</h1>
              <p className="mb-0 text-muted">
                Monitor and control all active sessions
              </p>
            </div>
            <div className="d-flex align-items-center gap-3 gap-md-4">
              <Button
                variant="success"
                onClick={() => {
                  fetchAvailableTables();
                  setShowStartSessionModal(true);
                }}
              >
                <RiPlayLine className="me-2" />
                Start New Session
              </Button>
              <div className="text-end">
                <p className="mb-0 small text-muted">Current Time</p>
                <p className="mb-0 fs-5 fw-semibold">{currentTime}</p>
              </div>
            </div>
          </div>
        </header>
        {/* Filter Bar */}
        <div className="mt-3">
          <div className="d-flex gap-2 flex-wrap">
            {/* Only show allowed table types in filter */}
            {[
              "All",
              ...allowedTableTypes.map(
                (type) => type.charAt(0).toUpperCase() + type.slice(1)
              ),
            ].map((type) => (
              <button
                key={type}
                type="button"
                onClick={() => setTableTypeFilter(type.toLowerCase())}
                className={`px-3 py-1 border fw-medium ${
                  tableTypeFilter === type.toLowerCase()
                    ? "border-dark text-dark rounded"
                    : "border-secondary text-muted rounded"
                }`}
                style={{
                  backgroundColor:
                    tableTypeFilter === type.toLowerCase()
                      ? "#facc15"
                      : "transparent",
                  minWidth: "110px",
                  textAlign: "center",
                  borderWidth: "2px",
                }}
              >
                {type}
              </button>
            ))}
          </div>
        </div>
        {/* Sessions Content */}
        <div className="flex-grow-1 mt-3">
          {viewMode === "grid" ? (
            <div className="row g-2 g-md-3">
              {filteredSessions.map((session) => (
                <div
                  key={session.id}
                  className="col-6 col-sm-4 col-md-3 col-lg-3"
                  onClick={() => handleSessionClick(session)}
                  style={{ cursor: "pointer" }}
                >
                  <div className="bg-white rounded-3 shadow-sm border overflow-hidden h-100 d-flex flex-column">
                    <div
                      className={`h-1 ${
                        session.status === "active"
                          ? "bg-success"
                          : session.status === "paused"
                          ? "bg-warning"
                          : "bg-secondary"
                      }`}
                    ></div>
                    <div className="p-2 p-md-3 flex-grow-1 d-flex flex-column">
                      <div className="d-flex align-items-center justify-content-between mb-2">
                        <div className="d-flex align-items-center gap-2">
                          <div
                            className={`rounded-3 d-flex align-items-center justify-content-center ${getTableIconBg(
                              session.table_type
                            )}`}
                            style={{ width: "32px", height: "32px" }}
                          >
                            {getTableIcon(session.table_type)}
                          </div>
                          <div>
                            <h3 className="mb-0 fw-semibold fs-6">
                              {session.table_name}
                            </h3>
                            <p className="mb-0 small text-muted text-capitalize">
                              {session.table_type}
                            </p>
                          </div>
                        </div>
                        <span
                          className={`px-2 py-1 rounded-pill small fw-medium ${getStatusBadgeClass(
                            session.status
                          )}`}
                        >
                          {session.status === "active"
                            ? "Active"
                            : session.status === "paused"
                            ? "Paused"
                            : "Ended"}
                        </span>
                      </div>
                      <div className="flex-grow-1">
                        {session.customer_name && (
                          <div className="d-flex align-items-center justify-content-between mb-1">
                            <span className="small text-muted">Customer</span>
                            <span className="fw-medium small">
                              {session.customer_name}
                            </span>
                          </div>
                        )}
                        <div className="d-flex align-items-center justify-content-between mb-1">
                          <span className="small text-muted">Started</span>
                          <span className="font-monospace fw-bold small">
                            {new Date(session.start_time).toLocaleTimeString()}
                          </span>
                        </div>
                        {session.status === "active" && session.time_limit && (
                          <div className="d-flex align-items-center justify-content-between mb-1">
                            <span className="small text-muted">Time Left</span>
                            <span
                              className={`fw-bold small ${
                                sessionTimers[session.id] <= 60
                                  ? "text-danger"
                                  : "text-success"
                              }`}
                            >
                              {sessionTimers[session.id] !== null
                                ? formatTime(sessionTimers[session.id])
                                : "Unlimited"}
                            </span>
                          </div>
                        )}
                        <div className="d-flex align-items-center justify-content-between mb-1">
                          <span className="small text-muted">Cost</span>
                          <span className="fw-bold text-primary small">
                            ${session.session_cost}
                          </span>
                        </div>
                        {session.table_type === "restaurant" && (
                          <div className="mt-2 text-center mb-2 w-80">
                            <button
                              type="button"
                              className="btn btn-sm btn-primary"
                              onClick={(e) => {
                                e.stopPropagation();
                                setSelectedSession(session);
                                setShowFoodModal(true);
                              }}
                            >
                              🍽 Order
                            </button>
                          </div>
                        )}
                      </div>
                      <div className="d-grid gap-1 gap-md-2">
                        <div className="d-flex gap-1">
                          {session.status === "active" && (
                            <Button
                              variant="warning"
                              size="sm"
                              className="flex-grow-1"
                              onClick={(e) => {
                                e.stopPropagation();
                                pauseSession(session.id);
                              }}
                            >
                              <RiPauseLine className="fs-6" />
                            </Button>
                          )}
                          {session.status === "paused" && (
                            <Button
                              variant="success"
                              size="sm"
                              className="flex-grow-1"
                              onClick={(e) => {
                                e.stopPropagation();
                                resumeSession(session.id);
                              }}
                            >
                              <RiPlayCircleLine className="fs-6" />
                            </Button>
                          )}
                          {session.status === "completed" ? (
                            <Button
                              variant="info"
                              size="sm"
                              className="flex-grow-1"
                              onClick={(e) => {
                                e.stopPropagation();
                                fetchBillForEndedSession(session);
                              }}
                            >
                              <RiPrinterLine className="fs-6" />
                            </Button>
                          ) : (
                            <Button
                              variant="danger"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                setSelectedSession(session);
                                handleCloseSession();
                              }}
                            >
                              <FaPowerOff className="me-1" />
                            </Button>
                          )}
                          <Button
                            variant="outline-secondary"
                            size="sm"
                            className="flex-grow-1"
                            onClick={(e) => {
                              e.stopPropagation();
                              handleSessionClick(session);
                            }}
                          >
                            Manage
                          </Button>
                        </div>
                        {/* Order button for active sessions */}
                        {session.status === "active" && (
                          <Button
                            variant="primary"
                            size="sm"
                            className="w-100"
                            onClick={(e) => {
                              e.stopPropagation();
                              navigate("/staff/ordermanagement", {
                                state: {
                                  session: session,
                                  fromSession: true,
                                },
                              });
                            }}
                          >
                            🍽 Order
                          </Button>
                        )}
                        <Button
                          variant="outline-danger"
                          size="sm"
                          className="w-100"
                          onClick={(e) => {
                            e.stopPropagation();
                            setSessionToDelete(session);
                            setShowDeleteConfirm(true);
                          }}
                        >
                          <RiDeleteBinLine className="me-1" /> Delete
                        </Button>
                      </div>
                    </div>
                  </div>
                </div>
              ))}
            </div>
          ) : (
            <div className="bg-white rounded-3 shadow-sm border overflow-hidden">
              <div className="table-responsive">
                <table className="table table-hover mb-0">
                  <thead className="table-light">
                    <tr>
                      <th>Session Info</th>
                      <th>Status</th>
                      <th>Start Time</th>
                      <th>Time Left</th>
                      <th>Cost</th>
                      <th className="text-end">Actions</th>
                    </tr>
                  </thead>
                  <tbody>
                    {filteredSessions.map((session) => (
                      <tr
                        key={session.id}
                        onClick={() => handleSessionClick(session)}
                        style={{ cursor: "pointer" }}
                      >
                        <td>
                          <div className="d-flex align-items-center gap-2 gap-md-3">
                            <div
                              className={`rounded-3 d-flex align-items-center justify-content-center ${getTableIconBg(
                                session.table_type
                              )}`}
                              style={{ width: "40px", height: "40px" }}
                            >
                              {getTableIcon(session.table_type)}
                            </div>
                            <div>
                              <h3 className="mb-0 fw-semibold fs-6 fs-md-5">
                                {session.table_name}
                              </h3>
                              <p className="mb-0 small text-muted text-capitalize">
                                {session.table_type}
                              </p>
                              {session.customer_name && (
                                <p className="mb-0 small text-muted">
                                  Customer: {session.customer_name}
                                </p>
                              )}
                            </div>
                          </div>
                        </td>
                        <td>
                          <span
                            className={`px-2 py-1 rounded-pill small fw-medium ${getStatusBadgeClass(
                              session.status
                            )}`}
                          >
                            {session.status === "active"
                              ? "Active"
                              : session.status === "paused"
                              ? "Paused"
                              : "Ended"}
                          </span>
                        </td>
                        <td>
                          <span className="font-monospace fw-bold small">
                            {new Date(session.created_at).toLocaleTimeString()}
                          </span>
                        </td>
                        <td>
                          {session.status === "active" ? (
                            <span
                              className={`fw-bold small ${
                                sessionTimers[session.id] <= 60
                                  ? "text-danger"
                                  : "text-success"
                              }`}
                            >
                              {sessionTimers[session.id] !== null
                                ? formatTime(sessionTimers[session.id])
                                : "Unlimited"}
                            </span>
                          ) : (
                            <span className="text-muted">-</span>
                          )}
                        </td>
                        <td>
                          <span className="fw-bold text-primary">
                            ${session.session_cost}
                          </span>
                        </td>
                        <td className="text-end">
                          <div className="d-flex align-items-center gap-2 gap-md-3 justify-content-end flex-wrap">
                            {session.status === "active" && (
                              <Button
                                variant="warning"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  pauseSession(session.id);
                                }}
                              >
                                <RiPauseLine className="me-1" /> Pause
                              </Button>
                            )}
                            {session.status === "paused" && (
                              <Button
                                variant="success"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  resumeSession(session.id);
                                }}
                              >
                                <RiPlayCircleLine className="me-1" /> Resume
                              </Button>
                            )}
                            {session.status === "completed" ? (
                              <Button
                                variant="info"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  fetchBillForEndedSession(session);
                                }}
                              >
                                <RiPrinterLine className="me-1" /> Show Bill
                              </Button>
                            ) : (
                              <Button
                                variant="danger"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  setSelectedSession(session);
                                  handleCloseSession(); // now shows loading inside
                                }}
                                disabled={loadingCustomerOrders} // prevent double-click
                              >
                                {loadingCustomerOrders &&
                                selectedSession?.id === session.id ? (
                                  <Spinner
                                    as="span"
                                    animation="border"
                                    size="sm"
                                  />
                                ) : (
                                  <RiStopLine className="me-1" />
                                )}
                                End
                              </Button>
                            )}
                            {/* Order button for active sessions */}
                            {session.status === "active" && (
                              <Button
                                variant="primary"
                                size="sm"
                                onClick={(e) => {
                                  e.stopPropagation();
                                  navigate("/staff/ordermanagement", {
                                    state: {
                                      session: session,
                                      fromSession: true,
                                    },
                                  });
                                }}
                              >
                                🍽 Order
                              </Button>
                            )}
                            <Button
                              variant="outline-danger"
                              size="sm"
                              onClick={(e) => {
                                e.stopPropagation();
                                setSessionToDelete(session);
                                setShowDeleteConfirm(true);
                              }}
                            >
                              <RiDeleteBinLine className="me-1" /> Delete
                            </Button>
                          </div>
                        </td>
                      </tr>
                    ))}
                  </tbody>
                </table>
              </div>
            </div>
          )}
        </div>
        {/* Session Management Modal */}
        <Modal
          show={showTableModal}
          onHide={() => setShowTableModal(false)}
          size="lg"
        >
          <Modal.Header closeButton>
            <Modal.Title>
              {selectedSession?.table_name} -{" "}
              {selectedSession?.table_type.toUpperCase()}
              {selectedSession?.customer_name && (
                <div className="small text-muted">
                  Customer: {selectedSession.customer_name}
                </div>
              )}
            </Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <h5 className="mb-3">Session Management</h5>
            <div className="bg-light p-3 rounded mb-3">
              <div className="row">
                <div className="col-md-6">
                  <div className="mb-2">
                    <span className="text-muted">Start Time:</span>
                    <span className="fw-bold ms-2">
                      {selectedSession &&
                        new Date(selectedSession.created_at).toLocaleString()}
                    </span>
                  </div>
                  <div className="mb-2">
                    <span className="text-muted">Status:</span>
                    <span
                      className={`fw-bold ms-2 ${getStatusBadgeClass(
                        selectedSession?.status
                      )}`}
                    >
                      {selectedSession?.status}
                    </span>
                  </div>
                  {selectedSession?.status === "active" && (
                    <div className="mb-2">
                      <span className="text-muted">Time Left:</span>
                      <span
                        className={`fw-bold ms-2 ${
                          sessionTimers[selectedSession?.id] <= 60
                            ? "text-danger"
                            : "text-success"
                        }`}
                      >
                        {sessionTimers[selectedSession?.id] !== null
                          ? formatTime(sessionTimers[selectedSession?.id])
                          : "Unlimited"}
                      </span>
                    </div>
                  )}
                </div>
                <div className="col-md-6">
                  <div className="mb-2">
                    <span className="text-muted">Current Cost:</span>
                    <span className="fw-bold text-primary ms-2">
                      ${selectedSession?.session_cost}
                    </span>
                  </div>
                  <div className="mb-2">
                    <span className="text-muted">Hourly Rate:</span>
                    <span className="fw-bold ms-2">
                      ${selectedSession?.hourly_rate}/hr
                    </span>
                  </div>
                  {selectedSession?.time_limit && (
                    <div className="mb-2">
                      <span className="text-muted">Time Limit:</span>
                      <span className="fw-bold ms-2">
                        {parseTimeLimit(selectedSession.time_limit) === 0
                          ? "Unlimited"
                          : `${parseTimeLimit(
                              selectedSession.time_limit
                            )} minutes`}
                      </span>
                    </div>
                  )}
                </div>
              </div>
            </div>
            <div className="d-flex flex-wrap gap-2 mb-3">
              {selectedSession?.status === "active" && (
                <Button
                  variant="warning"
                  onClick={() => pauseSession(selectedSession.id)}
                >
                  <RiPauseLine className="me-2" /> Pause
                </Button>
              )}
              {selectedSession?.status === "paused" && (
                <Button
                  variant="success"
                  onClick={() => resumeSession(selectedSession.id)}
                >
                  <RiPlayCircleLine className="me-2" /> Resume Session
                </Button>
              )}
              <Button
                variant="info"
                className="mb-2"
                onClick={() => {
                  setSessionToTransfer(selectedSession);
                  setTransferTableId(""); // Reset selection
                  setShowTransferModal(true);
                }}
              >
                Transfer
              </Button>
              <Button variant="light" className="mb-2">
                Show Time & Bill
              </Button>
            </div>
            <Button
              variant="danger"
              className="w-100"
              onClick={handleCloseSession}
            >
              Close Session & Print Bill
            </Button>
          </Modal.Body>
        </Modal>
        {/* Start Session Modal */}
        <Modal
          show={showStartSessionModal}
          onHide={() => setShowStartSessionModal(false)}
          size="lg"
        >
          <Modal.Header closeButton>
            <Modal.Title>Start New Session</Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <Form.Group className="mb-3">
              <Form.Label>Select Table</Form.Label>
              <Form.Select
                value={selectedTableForStart?.id || ""}
                onChange={(e) => {
                  const tableId = e.target.value;
                  const table = availableTables.find(
                    (t) => t.id.toString() === tableId
                  );
                  setSelectedTableForStart(table);
                  // Set default time limit and amount when table is selected
                  if (table) {
                    const defaultMinutes = 60; // Default 60 minutes
                    setTimeLimit(defaultMinutes);
                    const rate = table.hourly_rate || hourlyRate;
                    setAmount((defaultMinutes / 60) * rate);
                  }
                }}
              >
                <option value="">Select a table</option>
                {availableTables.map((table) => (
                  <option key={table.id} value={table.id}>
                    {table.table_name} ({table.table_type}) - $
                    {table.hourly_rate}/hr
                  </option>
                ))}
              </Form.Select>
            </Form.Group>
            {renderMemberSelect()}
            {selectedTableForStart?.table_type === "restaurant" &&
              renderMenuItems()}
            {selectedTableForStart?.table_type !== "restaurant" && (
              <div className="mb-3">
                <label className="form-label">Set Time Limit (minutes)</label>
                <input
                  type="number"
                  className="form-control"
                  value={timeLimit || ""} // Remove default 0
                  onChange={(e) => {
                    const minutes = Number(e.target.value);
                    setTimeLimit(minutes);
                    const rate =
                      selectedTableForStart?.hourly_rate || hourlyRate;
                    setAmount((minutes / 60) * rate);
                  }}
                  placeholder="Enter minutes (0 for unlimited)"
                  min="0"
                />
                <label className="form-label mt-3">Or Set by Amount ($)</label>
                <input
                  type="number"
                  className="form-control"
                  value={amount || ""} // Remove default 0
                  onChange={(e) => {
                    const money = Number(e.target.value);
                    setAmount(money);
                    const rate =
                      selectedTableForStart?.hourly_rate || hourlyRate;
                    setTimeLimit(Math.round((money / rate) * 60));
                  }}
                  placeholder="Enter amount"
                  min="0"
                  step="0.01"
                />
                <div className="mt-2">
                  <small>
                    {timeLimit > 0
                      ? `${timeLimit} minutes = $${
                          amount?.toFixed(2) || "0.00"
                        }`
                      : timeLimit === 0
                      ? "Unlimited time - billed when closed"
                      : "Enter time or amount"}
                  </small>
                </div>
              </div>
            )}
            <Button
              variant="success"
              className="w-100 mt-3"
              onClick={startNewSession}
              disabled={!selectedTableForStart || isStartingSession}
            >
              {isStartingSession ? (
                <>
                  <Spinner
                    as="span"
                    animation="border"
                    size="sm"
                    role="status"
                    aria-hidden="true"
                  />
                  <span className="ms-2">Starting Session...</span>
                </>
              ) : (
                "Start Session"
              )}
            </Button>
          </Modal.Body>
        </Modal>
        {/* Close confirmation modal */}
        {/* ✅ UPDATED: Close confirmation modal */}
        <Modal
          show={showCloseConfirm}
          onHide={handleCloseConfirmModal} // 👈 uses new handler
        >
          <Modal.Header closeButton>
            <Modal.Title>Confirm Close Session</Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <p>
              Are you sure you want to close this session? This will print the
              bill and clear all orders for the table.
            </p>
            <div className="bg-light p-3 rounded">
              <div className="d-flex justify-content-between">
                <div>
                  <span className="text-muted">Table:</span>
                  <span className="fw-bold ms-2">
                    {selectedSession?.table_name}
                  </span>
                </div>
                {selectedSession?.customer_name && (
                  <div className="mt-2">
                    <span className="text-muted">Customer:</span>
                    <span className="fw-bold ms-2">
                      {selectedSession.customer_name}
                    </span>
                  </div>
                )}
              </div>

              <div className="d-flex justify-content-between mt-2">
                <div>
                  <span className="text-muted">Table Number:</span>
                  <span className="fw-bold text-primary ms-2">
                    {selectedSession?.table_number}
                  </span>
                </div>
                <div>
                  <span className="text-muted">Current Cost:</span>
                  <span className="fw-bold text-primary ms-2">
                    ${selectedSession?.session_cost}
                  </span>
                </div>
              </div>

              <div className="d-flex justify-content-between mt-2">
                <div>
                  <span className="text-muted">Start Time:</span>
                  <span className="fw-bold text-primary ms-2">
                    {new Date(selectedSession?.start_time).toLocaleTimeString(
                      [],
                      { hour: "2-digit", minute: "2-digit" }
                    )}
                  </span>
                </div>
                <div>
                  <span className="text-muted">End Time:</span>
                  <span className="fw-bold text-primary ms-2">
                    {selectedSession?.status === "active" &&
                    selectedSession?.start_time
                      ? (() => {
                          const start = new Date(selectedSession.start_time);
                          const diffMs = Date.now() - start.getTime(); // elapsed since start
                          const endTime = new Date(start.getTime() + diffMs); // calculated end time

                          // Format time as "hh:mm AM/PM"
                          const hours = endTime.getHours() % 12 || 12;
                          const minutes = endTime
                            .getMinutes()
                            .toString()
                            .padStart(2, "0");
                          const ampm = endTime.getHours() >= 12 ? "PM" : "AM";
                          return `${hours}:${minutes} ${ampm}`;
                        })()
                      : selectedSession?.end_time
                      ? // if session is not active, show stored end_time
                        (() => {
                          const end = new Date(selectedSession.end_time);
                          const hours = end.getHours() % 12 || 12;
                          const minutes = end
                            .getMinutes()
                            .toString()
                            .padStart(2, "0");
                          const ampm = end.getHours() >= 12 ? "PM" : "AM";
                          return `${hours}:${minutes} ${ampm}`;
                        })()
                      : "—"}
                  </span>
                </div>
              </div>

              <div className="d-flex justify-content-between mt-2">
                <span className="text-muted">Total Time:</span>
                <span className="fw-bold text-primary ms-2">
                  {selectedSession?.status === "active" &&
                  selectedSession?.start_time
                    ? (() => {
                        const diffMs =
                          Date.now() -
                          new Date(selectedSession.start_time).getTime();
                        const totalMinutes = Math.floor(diffMs / 60000);
                        const hours = Math.floor(totalMinutes / 60);
                        const minutes = totalMinutes % 60;

                        // Format output like "1 hr 45 min", "2 hr", "30 min"
                        if (hours > 0 && minutes > 0)
                          return `${hours} hr ${minutes} min`;
                        if (hours > 0) return `${hours} hr`;
                        return `${minutes} min`;
                      })()
                    : "—"}
                </span>
              </div>
            </div>

            {/* Customer Orders Section */}
            {loadingCustomerOrders ? (
              <div className="mt-3 text-center">
                <Spinner animation="border" size="sm" />
                <span className="ms-2">Loading customer orders...</span>
              </div>
            ) : customerOrders.length > 0 ? (
              <div className="mt-3">
                <h6 className="fw-bold">Customer Orders</h6>
                <div
                  className="border rounded p-2"
                  style={{ maxHeight: "200px", overflowY: "auto" }}
                >
                  {customerOrders.map((order, index) => (
                    <div key={index} className="mb-2 pb-2 border-bottom">
                      <div className="d-flex justify-content-between">
                        <span className="fw-medium">
                          Order #{order.order_number || index + 1}
                        </span>
                        <span className="fw-bold">
                          ${parseFloat(order.total_amount || 0).toFixed(2)}
                        </span>
                      </div>
                      {order.items && order.items.length > 0 && (
                        <div className="mt-1">
                          {order.items.slice(0, 3).map((item, itemIndex) => (
                            <div key={itemIndex} className="small text-muted">
                              {item.quantity}x{" "}
                              {item.item_details?.item_name ||
                                `Item #${item.id}`}
                            </div>
                          ))}
                          {order.items.length > 3 && (
                            <div className="small text-muted">
                              +{order.items.length - 3} more items
                            </div>
                          )}
                        </div>
                      )}
                    </div>
                  ))}
                </div>
              </div>
            ) : (
              <div className="mt-3 text-center text-muted">
                No customer orders found for this session.
              </div>
            )}

            {/* Total Cost Section */}
            <div className="mt-3 p-3 bg-light rounded">
              <div className="d-flex justify-content-between">
                <span className="fw-bold">Table Usage Cost:</span>
                <span className="fw-bold">
                  ${selectedSession?.session_cost || "0.00"}
                </span>
              </div>
              <div className="d-flex justify-content-between">
                <span className="fw-bold">Orders Total:</span>
                <span className="fw-bold">
                  $
                  {customerOrders
                    .reduce(
                      (sum, order) => sum + parseFloat(order.total_amount || 0),
                      0
                    )
                    .toFixed(2)}
                </span>
              </div>
              <div className="d-flex justify-content-between mt-2 pt-2 border-top">
                <span className="fw-bold fs-5">Total Amount:</span>
                <span className="fw-bold fs-5 text-primary">
                  ${calculateTotalCost().toFixed(2)}
                </span>
              </div>
            </div>
          </Modal.Body>
          <Modal.Footer>
            <Button
              variant="secondary"
              onClick={handleCloseConfirmModal} // 👈 reset on cancel
            >
              Cancel
            </Button>
            <Button
              variant="danger"
              onClick={confirmCloseAndPrint}
              disabled={isClosingSession}
            >
              {isClosingSession ? (
                <>
                  <Spinner as="span" animation="border" size="sm" />
                  <span className="ms-2">Processing...</span>
                </>
              ) : (
                "Confirm & Print"
              )}
            </Button>
          </Modal.Footer>
        </Modal>

        {/* Delete confirmation modal */}
        <Modal
          show={showDeleteConfirm}
          onHide={() => setShowDeleteConfirm(false)}
        >
          <Modal.Header closeButton>
            <Modal.Title>Confirm Delete Session</Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <p>
              Are you sure you want to delete this session? This action cannot
              be undone.
            </p>
            <div className="bg-light p-3 rounded">
              <div className="d-flex justify-content-between">
                <div>
                  <span className="text-muted">Table:</span>
                  <span className="fw-bold ms-2">
                    {sessionToDelete?.table_name}
                  </span>
                </div>
                <div>
                  <span className="text-muted">Status:</span>
                  <span
                    className={`fw-bold ms-2 ${getStatusBadgeClass(
                      sessionToDelete?.status
                    )}`}
                  >
                    {sessionToDelete?.status}
                  </span>
                </div>
              </div>
              {sessionToDelete?.customer_name && (
                <div className="mt-2">
                  <span className="text-muted">Customer:</span>
                  <span className="fw-bold ms-2">
                    {sessionToDelete.customer_name}
                  </span>
                </div>
              )}
            </div>
          </Modal.Body>
          <Modal.Footer>
            <Button
              variant="secondary"
              onClick={() => setShowDeleteConfirm(false)}
            >
              Cancel
            </Button>
            <Button
              variant="danger"
              onClick={deleteSession}
              disabled={isDeletingSession}
            >
              {isDeletingSession ? (
                <>
                  <Spinner
                    as="span"
                    animation="border"
                    size="sm"
                    role="status"
                    aria-hidden="true"
                  />
                  <span className="ms-2">Deleting...</span>
                </>
              ) : (
                "Delete Session"
              )}
            </Button>
          </Modal.Footer>
        </Modal>
        {/* Transfer Session Modal - Updated for table transfer */}
        <Modal
          show={showTransferModal}
          onHide={() => setShowTransferModal(false)}
        >
          <Modal.Header closeButton>
            <Modal.Title>Transfer Session to Another Table</Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <p>
              Transfer session for{" "}
              <strong>{sessionToTransfer?.table_name}</strong> to another
              electric table:
            </p>
            {sessionToTransfer && (
              <div className="bg-light p-3 rounded mb-3">
                <div className="d-flex justify-content-between mb-1">
                  <span className="text-muted">Customer:</span>
                  <span className="fw-bold">
                    {sessionToTransfer.customer_name || "Guest"}
                  </span>
                </div>
                {sessionToTransfer.customer_phone && (
                  <div className="d-flex justify-content-between mb-1">
                    <span className="text-muted">Phone:</span>
                    <span className="fw-bold">
                      {sessionToTransfer.customer_phone}
                    </span>
                  </div>
                )}
                <div className="d-flex justify-content-between mb-1">
                  <span className="text-muted">Time Limit:</span>
                  <span className="fw-bold">
                    {parseTimeLimit(sessionToTransfer.time_limit) === 0
                      ? "Unlimited"
                      : `${parseTimeLimit(
                          sessionToTransfer.time_limit
                        )} minutes`}
                  </span>
                </div>
              </div>
            )}
            <Form.Group className="mb-3">
              <Form.Label>Select Electric Table</Form.Label>
              <Dropdown>
                <Dropdown.Toggle
                  variant="light"
                  id="dropdown-table-select"
                  style={{
                    width: "100%",
                    textAlign: "left",
                    color: "#000",
                    backgroundColor: "#fff",
                    border: "1px solid #ced4da",
                    padding: "0.375rem 0.75rem",
                    fontSize: "1rem",
                    lineHeight: "1.5",
                    borderRadius: "0.25rem",
                  }}
                >
                  {transferTableId
                    ? electricTables.find(
                        (table) => table.id === transferTableId
                      )?.table_name +
                      " (" +
                      electricTables.find(
                        (table) => table.id === transferTableId
                      )?.table_type +
                      ") - $" +
                      electricTables.find(
                        (table) => table.id === transferTableId
                      )?.hourly_rate +
                      "/hr"
                    : "Select a table"}
                </Dropdown.Toggle>
                <Dropdown.Menu
                  style={{
                    width: "100%",
                    maxHeight: "200px",
                    overflowY: "auto",
                    backgroundColor: "#fff",
                  }}
                >
                  {electricTables.map((table) => (
                    <Dropdown.Item
                      key={table.id}
                      onClick={() => setTransferTableId(table.id)}
                      style={{ color: "#000" }}
                    >
                      {table.table_name} ({table.table_type}) - $
                      {table.hourly_rate}/hr
                    </Dropdown.Item>
                  ))}
                </Dropdown.Menu>
              </Dropdown>
            </Form.Group>
            <div className="alert alert-info">
              <i className="ri-information-line me-2"></i>
              This will end the current session and start a new one on the
              selected table with the same customer and time limit.
            </div>
          </Modal.Body>
          <Modal.Footer>
            <Button
              variant="secondary"
              onClick={() => setShowTransferModal(false)}
            >
              Cancel
            </Button>
            <Button
              variant="primary"
              onClick={async () => {
                if (!transferTableId) {
                  alert("Please select a table");
                  return;
                }
                const success = await transferSession(
                  sessionToTransfer.id,
                  transferTableId
                );
                if (success) {
                  setShowTransferModal(false);
                  setShowTableModal(false);

                  // Refresh sessions data from the server
                  await fetchSessions();
                }
              }}
              disabled={!transferTableId}
            >
              Transfer Session
            </Button>
          </Modal.Footer>
        </Modal>
        {/* Food Order Modal */}
        <Modal
          show={showFoodModal}
          onHide={() => setShowFoodModal(false)}
          centered
        >
          <Modal.Header closeButton>
            <Modal.Title>Order Food</Modal.Title>
          </Modal.Header>
          <Modal.Body>{renderMenuItems()}</Modal.Body>
          <Modal.Footer>
            <Button variant="secondary" onClick={() => setShowFoodModal(false)}>
              Cancel
            </Button>
            <Button
              variant="primary"
              onClick={() => {
                if (selectedItems.length === 0) {
                  alert("Please select at least one item to order.");
                  return;
                }
                navigate("/staff/ordermanagement");
                setShowFoodModal(false);
              }}
            >
              Place Order
            </Button>
          </Modal.Footer>
        </Modal>
        {/* Bill Modal */}
        <Modal
          show={showBillModal}
          onHide={() => setShowBillModal(false)}
          centered
          size="md"
          dialogClassName="bill-modal"
        >
          <Modal.Body className="p-4">
            {billData && (
              <div
                id="bill-content"
                className="p-3 border border-2 border-dark"
              >
                <div className="text-center mb-3">
                  <h4 className="fw-bold">BILL RECEIPT</h4>
                  <p className="mb-0">Session ID: {billData.sessionId}</p>
                </div>
                <div className="mb-3">
                  <div className="d-flex justify-content-between mb-1">
                    <span>Table:</span>
                    <span className="fw-bold">
                      {billData.tableName} ({billData.tableType})
                    </span>
                  </div>
                  <div className="d-flex justify-content-between mb-1">
                    <span>Customer:</span>
                    <span className="fw-bold">{billData.customerName}</span>
                  </div>
                  <div className="d-flex justify-content-between mb-1">
                    <span>Start Time:</span>
                    <span>{billData.startTime}</span>
                  </div>
                  <div className="d-flex justify-content-between mb-1">
                    <span>End Time:</span>
                    <span>{billData.endTime}</span>
                  </div>
                  <div className="d-flex justify-content-between mb-1">
                    <span>Duration:</span>
                    <span>{billData.duration}</span>
                  </div>
                </div>
                <div className="mb-3">
                  <div className="d-flex justify-content-between mb-1">
                    <span>Table Usage:</span>
                    <span>${billData.tableCost.toFixed(2)}</span>
                  </div>
                  <div className="d-flex justify-content-between mb-1">
                    <span>Hourly Rate:</span>
                    <span>${billData.hourlyRate.toFixed(2)}/hr</span>
                  </div>
                </div>
                {billData.orders && billData.orders.length > 0 && (
                  <div className="mb-3">
                    <h6 className="fw-bold mb-2">Orders:</h6>
                    {billData.orders.map((order, index) => (
                      <div key={index} className="mb-2">
                        <div className="d-flex justify-content-between">
                          <span>Order {order.order_number}</span>
                          <span>
                            ${parseFloat(order.total_amount).toFixed(2)}
                          </span>
                        </div>
                        {order.special_instructions && (
                          <div className="small text-muted ms-3">
                            Special: {order.special_instructions}
                          </div>
                        )}
                      </div>
                    ))}
                    <div className="d-flex justify-content-between mt-2 pt-2 border-top">
                      <span>Orders Total:</span>
                      <span>${billData.ordersTotal.toFixed(2)}</span>
                    </div>
                  </div>
                )}
                <div className="border-top pt-2">
                  <div className="d-flex justify-content-between mb-1">
                    <span>Subtotal:</span>
                    <span>${billData.subtotal.toFixed(2)}</span>
                  </div>
                  <div className="d-flex justify-content-between mb-1">
                    <span>Tax ({billData.taxRate}%):</span>
                    <span>${billData.tax.toFixed(2)}</span>
                  </div>
                  <div className="d-flex justify-content-between fw-bold fs-5">
                    <span>TOTAL:</span>
                    <span>${billData.total.toFixed(2)}</span>
                  </div>
                </div>
                <div className="text-center mt-4">
                  <p className="small mb-0">Thank you for your business!</p>
                  <p className="small mb-0">
                    {new Date().toLocaleDateString()}
                  </p>
                </div>
              </div>
            )}
          </Modal.Body>
          <Modal.Footer className="d-flex justify-content-between">
            <Button variant="secondary" onClick={() => setShowBillModal(false)}>
              Close
            </Button>
            <div className="d-flex gap-2">
              <Button
                variant="outline-primary"
                onClick={() => setShowPrinterSettings(true)}
              >
                Printer Settings
              </Button>
              <Button variant="primary" onClick={printBill}>
                <RiPrinterLine className="me-2" /> Print to Wi-Fi Printer
              </Button>
            </div>
          </Modal.Footer>
        </Modal>
        {/* Printer Settings Modal */}
        <Modal
          show={showPrinterSettings}
          onHide={() => setShowPrinterSettings(false)}
        >
          <Modal.Header closeButton>
            <Modal.Title>Printer Settings</Modal.Title>
          </Modal.Header>
          <Modal.Body>
            <Form>
              <Form.Group className="mb-3">
                <Form.Label>Printer IP Address</Form.Label>
                <Form.Control
                  type="text"
                  value={printerConfig.host}
                  onChange={(e) =>
                    setPrinterConfig({
                      ...printerConfig,
                      host: e.target.value,
                    })
                  }
                  placeholder="e.g. 192.168.1.100"
                />
              </Form.Group>
              <Form.Group className="mb-3">
                <Form.Label>Printer Port</Form.Label>
                <Form.Control
                  type="number"
                  value={printerConfig.port}
                  onChange={(e) =>
                    setPrinterConfig({
                      ...printerConfig,
                      port: parseInt(e.target.value) || 9100,
                    })
                  }
                  placeholder="e.g. 9100"
                />
              </Form.Group>
              <Form.Group className="mb-3">
                <Form.Label>Printer Type</Form.Label>
                <Form.Select
                  value={printerConfig.type}
                  onChange={(e) =>
                    setPrinterConfig({
                      ...printerConfig,
                      type: e.target.value,
                    })
                  }
                >
                  <option value="epson">Epson</option>
                  <option value="star">Star</option>
                </Form.Select>
              </Form.Group>
              <Button
                variant="outline-secondary"
                onClick={testPrint}
                className="w-100 mb-2"
              >
                Test Print
              </Button>
            </Form>
          </Modal.Body>
          <Modal.Footer>
            <Button
              variant="secondary"
              onClick={() => setShowPrinterSettings(false)}
            >
              Cancel
            </Button>
            <Button variant="primary" onClick={savePrinterSettings}>
              Save Settings
            </Button>
          </Modal.Footer>
        </Modal>
      </div>
      {/* Toast Notification */}
      <ToastNotification />
      {/* Custom CSS */}
      <style jsx global>{`
        .w-sidebar {
          width: 16rem;
        }
        .hover-bg-gray:hover {
          background-color: #f8f9fa;
        }
        .bg-gray-100 {
          background-color: #f8f9fa;
        }
        .text-purple {
          color: #6f42c1;
        }
        .bg-purple {
          background-color: #ddd2f1ff;
        }
        .toggle-switch {
          width: 40px;
          height: 20px;
          background-color: #e9ecef;
          border-radius: 20px;
          position: relative;
          cursor: pointer;
          transition: background-color 0.3s;
        }
        .toggle-switch.active {
          background-color: #198754;
        }
        .toggle-slider {
          width: 16px;
          height: 16px;
          background-color: white;
          border-radius: 50%;
          position: absolute;
          top: 2px;
          left: 2px;
          transition: transform 0.3s;
          box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
        }
        .toggle-switch.active .toggle-slider {
          transform: translateX(20px);
        }
        .x-small {
          font-size: 0.75rem;
        }
        @media (max-width: 576px) {
          .table-responsive {
            font-size: 0.875rem;
          }
        }
        .bill-modal .modal-body {
          background-color: #f8f9fa;
        }
        #bill-content {
          background-color: white;
          font-family: "Courier New", monospace;
          width: 100%;
          min-height: auto;
          padding: 10mm;
          box-sizing: border-box;
          max-width: 210mm;
          margin: 0 auto;
        }
        @media print {
          body * {
            visibility: hidden;
          }
          #bill-content,
          #bill-content * {
            visibility: visible;
          }
          #bill-content {
            position: absolute;
            left: 0;
            top: 0;
            width: 100%;
            padding: 10mm;
            margin: 0 auto;
          }
          .bill-modal .modal-footer,
          .bill-modal .modal-header {
            display: none !important;
          }
          @page {
            margin: 10mm;
          }
        }
      `}</style>
    </div>
  );
};

export default TablesManagement;
